; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "PVM"
#define MyAppVersion "1.3.1"
#define MyAppPublisher "hjb.dev"
#define MyAppURL "https://github.com/hjbdev/pvm"
#define MyAppExeName "pvm.exe"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{DA006438-7CC4-41E4-B2BF-2AD84AAA18E9}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={%USERPROFILE}\.pvm
UninstallDisplayIcon={app}\{#MyAppExeName}
; "ArchitecturesAllowed=x64compatible" specifies that Setup cannot run
; on anything but x64 and Windows 11 on Arm.
ArchitecturesAllowed=x64os
; "ArchitecturesInstallIn64BitMode=x64compatible" requests that the
; install be done in "64-bit mode" on x64 or Windows 11 on Arm,
; meaning it should use the native 64-bit Program Files directory and
; the 64-bit view of the registry.
ArchitecturesInstallIn64BitMode=x64compatible
DefaultGroupName={#MyAppName}
AllowNoIcons=yes
LicenseFile=LICENSE
InfoAfterFile=README.md
; Uncomment the following line to run in non administrative install mode (install for current user only).
PrivilegesRequired=lowest
PrivilegesRequiredOverridesAllowed=dialog
OutputDir=.
OutputBaseFilename=pvm-setup
SolidCompression=yes
WizardStyle=modern

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Files]
Source: "src\{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Dirs]
Name: "{app}\bin"
Name: "{app}\versions"

[UninstallDelete]
Type: filesandordirs; Name: "{app}"

[Code]
var
  path: string;

procedure InitializePath();
begin
  if RegQueryStringValue(HKEY_CURRENT_USER, 'Environment', 'Path', path) then
  begin
    if Pos(ExpandConstant('{app}'), path) = 0 then
    begin
      // Check if PATH is empty
      if path <> '' then
        path := path + ';';
        
      // Add the app directory and bin directory to the PATH  
      path := path + ExpandConstant('{app}') + ';' + ExpandConstant('{app}') + '\bin';
      
      // Remove extra semicolons (e.g., ;; becomes ; or ;;; becomes ;)
      StringChangeEx(path, ';;', ';', True);

      // Remove any leading semicolon at the start of the path if present
      if (Pos(';', path) = 1) then
        path := Copy(path, 2, Length(path) - 1);

      // Ensure there's no trailing semicolon at the end of the path
      if (Pos(';', path) = Length(path)) then
        path := Copy(path, 1, Length(path) - 1);
      
      // Write the added path back to the registry
      RegWriteExpandStringValue(HKEY_CURRENT_USER, 'Environment', 'Path', path);
    end;
  end
  else
  begin
    MsgBox('Unable to read PATH environment variable.', mbError, MB_OK);
  end;
end;

procedure RemovePath();
begin
  if RegQueryStringValue(HKEY_CURRENT_USER, 'Environment', 'Path', path) then
  begin
    // Remove the app directory and bin directory from the PATH
    StringChangeEx(path, ExpandConstant('{app}') + ';', '', True);
    StringChangeEx(path, ExpandConstant('{app}') + '\bin' + ';', '', True);

    // Remove extra semicolons (e.g., ;; becomes ; or ;;; becomes ;)
    StringChangeEx(path, ';;', ';', True);

    // Remove any leading semicolon at the start of the path if present
    if (Pos(';', path) = 1) then
      path := Copy(path, 2, Length(path) - 1);

    // Ensure there's no trailing semicolon at the end of the path
    if (Pos(';', path) = Length(path)) then
      path := Copy(path, 1, Length(path) - 1);

    // Write the cleaned path back to the registry
    RegWriteExpandStringValue(HKEY_CURRENT_USER, 'Environment', 'Path', path);
  end
  else
  begin
    MsgBox('Unable to read PATH environment variable.', mbError, MB_OK);
  end;
end;

procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssPostInstall then
  begin
    InitializePath();
  end
end;

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
begin
  if CurUninstallStep = usUninstall then
  begin
    RemovePath();
  end;
end;


